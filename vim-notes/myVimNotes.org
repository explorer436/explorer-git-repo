* My Vim notes                                                          :TOC:
  - [[#helpful-tips-related-to-configuration-and-other-things-related-to-vim-that-i-find-useful][Helpful tips related to configuration and other things related to Vim that I find useful.]]

** Helpful tips related to configuration and other things related to Vim that I find useful.

*** Movement

Moving the cursor gracefully without moving the page:

Basic Movement of the cursor:

| h l k j          | character left, right; line up, down                                                                                                                                                                                                                                                               |
| b w              | word/token left, right                                                                                                                                                                                                                                                                             |
| ge e             | end of word/token left, right                                                                                                                                                                                                                                                                      |
| gm               | middle of line                                                                                                                                                                                                                                                                                     |
| nG ngg           | line n, default the last, first                                                                                                                                                                                                                                                                    |
| n%               | percentage n of the file (n must be provided)                                                                                                                                                                                                                                                      |
| n                | column n of current line                                                                                                                                                                                                                                                                           |
| %                | match of next brace, bracket, comment, #define. move to the next or previous related item. Items include brackets, opening and closing c-style comments, and C preprocessor conditionals. I find myself using % a lot depending on the programming language.                                       |
| nH               | line n from start of window                                                                                                                                                                                                                                                                        |
| nL               | line n from bottom of window                                                                                                                                                                                                                                                                       |
| M                | middle line of window                                                                                                                                                                                                                                                                              |
| (minus)          | move the cursor to the first non-blank character on the previous line                                                                                                                                                                                                                              |
| (plus)           | move the cursor to the first non-blank character on the next line                                                                                                                                                                                                                                  |
| M/H/L            | move cursor to middle/top/bottom of screen (Move the cursor only. Do not move the screen)                                                                                                                                                                                           |
| ^ and g_         | move the cursor to the first and last non blank characters in a line                                                                                                                                                                                                                          |
| 0 and $          | move the cursor to the first and last characters in the current line                                                                                                                                                                                                                              |
| ( )              | move the cursor to the beginning of previous, next sentence                                                                                                                                                                                                                                        |
| { and }          | Move the cursor to the beginning of previous or next paragraph.  The definition of a paragraph is based on nroff macros (read man nroff if you want to figure out what that means). This generally works quite well for navigating between large space-separated blocks in a programming language. |

Complex movement of the cursor:

| B W                           | space-separated word left, right                                   |
| gE E                          | end of space-separated word left, right                            |
| n_                            | down n-1 line on first non-blank character                         |
| g0                            | beginning of screen line                                           |
| g^  g$                        | first, last character of screen line                               |
| gk gj                         | screen line up, down                                               |
| fc Fc                         | next, previous occurence of character c                            |
| tc Tc                         | before next, previous occurence of c                               |
| ; ,                           | repeat last fFtT, in opposite direction                            |
| (Two square bracket openings) | start of section backward                                          |
| ]]                            | start of section forward                                           |
| [] ][                         | end of section backward, forward                                   |
| [( ])                         | unclosed (, ) backward, forward                                    |
| [{  ]}                        | unclosed {, } backward, forward                                    |
| [m ]m                         | start of backward, forward Java method                             |
| [# ]#                         | unclosed #if, #else, #endif backward, forward                      |
| [* ]*                         | start, end of /* */ backward, forward                              |

   ------------------------------------------

*** Scrolling 

Scroll up and down through a page gracefully using Vim the following keystrokes:

Move the page using these commands:

| zt or z↵         | set current line at top of window. move current line to the top of the screen                                                                                                      |
| zz or z.         | set current line at center of window. move current line to the middle of the screen (Careful with zz, if you happen to have Caps Lock on accidentally, you will save and exit vim) |
| zb or z-         | set current line at bottom of window. move current line to the bottom of the screen                                                                                                |
| zh zl            | scroll one character to the right, left                                                                                                                                            |
| zH zL            | scroll half a screen to the right, left                                                                                                                                            |
| [Control][b]     | Moves screen up (backward) one page, cursor to last line                                                                                                                           |
| [Control][f]     | Moves screen down (forward) one page, cursor to first line                                                                                                                         |
| [Control][u]     | Moves cursor & screen up ½ page (Half-page navigations)                                                                                                                            |
| [Control][d]     | Moves cursor & screen down ½ page (Half-page navigations)                                                                                                                          |
| [Control][E]     | move the page/screen up by one line (One-line movements)                                                                                                                           |
| [Control][Y]     | move the page/screen down by one line (One-line movements)                                                                                                                         |
| :N               | Go to line N                                                                                                                                                                       |
| N%               | Go to the line N percent through the file                                                                                                                                          |
| N(vertical pipe) | Go to column N                                                                                                                                                                     |
    
I lose visual context every time for the former two, so I have developed the bad habit of hitting the latter (Ctrl-Y and Ctrl-E) repetitively. Ctrl-y and Ctrl-e only change the cursor position if it would be moved off screen.

To leave the cursor in the same column when you use Ctrl+D, Ctrl+F, Ctrl+B, Ctrl+U, G, H, M, L, gg you should define the following option:
#+BEGIN_EXAMPLE
:set nostartofline
#+END_EXAMPLE

   ------------------------------------------

*** Folding

| zfm         | create fold of movement m                |
| :rfo        | create fold for range r                  |
| zd zE       | delete fold at cursor, all in window     |
| zo zc zO zC | open, close one fold; recursively        |
| [z ]z       | move to start, end of current open fold  |
| zj zk       | move down, up to start, end of next fold |

   ------------------------------------------

*** Insertion & replace → insert mode

| i a     | insert before, after cursor                   |
| I A     | insert at beginning, end of line              |
| gI      | insert text in first column                   |
| o O     | open a new line below, above the current line |
| rc      | replace character under cursor with c         |
| grc     | like r, but without affecting layout          |
| R       | replace characters starting at the cursor     |
| gR      | like R, but without affecting layout          |
| cm      | change text of movement command m             |
| cc or S | change current line                           |
| C       | change to the end of line                     |
| s       | change one character and insert               |
| ~       | switch case and advance cursor                |
| g~m     | switch case of movement command m             |
| gum gUm | lowercase, uppercase text of movement m       |
| <m >m   | shift left, right text of movement m          |
| n<< n>> | shift n lines left, right                     |

INSERT MODE

| ^Vc ^Vn         | insert char c literally, decimal value n      |
| ^A              | insert previously inserted text               |
| ^@              | same as ^A and stop insert → command mode     |
| ^Rx ^R^Rx       | insert content of register x, literally       |
| ^N ^P           | text completion before, after cursor          |
| ^W              | delete word before cursor                     |
| ^U              | delete all inserted character in current line |
| ^D ^T           | shift left, right one shift width             |
| ^Kc1c2 or c1←c2 | enter digraph \c1,c2\                         |
| ^Oc             | execute c in temporary command mode           |
| ^X^E ^X^Y       | scroll up, down                               |
| <esc> or ^[     | abandon edition → command mode                |

ADVANCED INSERTION

| g?m     | perform rot13 encoding on movement m         |
| n^A n^X | +n, -n to number under cursor                |
| gqm     | format lines of movement m to fixed width    |
| :rce w↵ | center lines in range r to width w           |
| :rle i↵ | left align lines in range r with indent i    |
| :rri w↵ | right align lines in range r to width w      |
| !mc↵    | filter lines of movement m through command c |
| n!!c↵   | filter n lines through command c             |
| :r!c↵   | filter range r lines through command c       |

*** Search and Substitution
 
| What to Type | What it does                                            |
| [i           | show first line containing word under the cursor        |
| [I or ]I     | show every line containing word under the cursor        |
| :g/pattern/  | show every line matching the regular expression pattern |

SEARCH & SUBSTITUTION

| /s↵  ?s↵     | search forward, backward for s                                       |
| /s/o↵  ?s?o↵ | search fwd, bwd for s with offset o                                  |
| n or /↵      | repeat forward last search                                           |
| N or ?↵      | repeat backward last search                                          |
| # *          | search backward, forward for word under cursor                       |
| g# g*        | same, but also find partial matches                                  |
| gd gD        | local, global definition of symbol under cursor                      |
| :rs/f/t/x↵   | substitute f by t in range r x: g-all occurrences, c-confirm changes |
| :rs x↵       | repeat substitution with new r & x                                   |

SPECIAL CHARACTERS IN SEARCH PATTERNS

| .   ^  $    | any single character, start, end of line   |
| \< \>       | start, end of word                         |
| [c1-c2]     | a single character in range c1..c2         |
| [^c1-c2]    | a single character not in range            |
| \i \k \I \K | an identifier, keyword; excl. digits       |
| \f \p \F \P | a file name, printable char.; excl. digits |
| \s \S       | a white space, a non-white space           |
| \e \t \r \b | <esc>, <tab>, <↵>, <←>                     |
| \= * \+     | match 0..1, 0..∞, 1..∞ of preceding atoms  |
| \(pipe)     | separate two branches ( ≡ or)              |
| \( \)       | group patterns into an atom                |
| \& \n       | the whole matched pattern, nth () group    |
| \u \l       | next character made upper, lowercase       |
| \c \C       | ignore, match case on next pattern         |

OFFSETS IN SEARCH COMMANDS

| n or +n  | n line downward in column 1                |
| (minus)n | n line upward in column 1                  |
| e+n e-n  | n characters right, left to end of match   |
| s+n s-n  | n characters right, left to start of match |
| ;sc      | execute search command sc next             |

   ------------------------------------------

*** Sorting

   Imagine you’re working in vim. You come across this code:

#+BEGIN_EXAMPLE
	gem 'clearance', '1.0.0.rc4'
	gem 'neat'
	gem 'stripe'
	gem 'pg'
	gem 'thin'
	gem 'rails', '3.2.11'
	gem 'bourbon'
	gem 'simple_form'
	gem 'strong_parameters'
#+END_EXAMPLE

	If you want to sort the list alphabetically, select the lines visually and run the command:
	
#+BEGIN_EXAMPLE
	:sort
#+END_EXAMPLE

	That will result in this:
	
#+BEGIN_EXAMPLE
	gem 'bourbon'
	gem 'clearance', '1.0.0.rc4'
	gem 'neat'
	gem 'pg'
	gem 'rails', '3.2.11'
	gem 'simple_form'
	gem 'stripe'
	gem 'strong_parameters'
	gem 'thin'
#+END_EXAMPLE

	If you want to dig deeper into the sort functionality:
#+BEGIN_EXAMPLE
	:help sort
#+END_EXAMPLE
 
   ------------------------------------------

*** Spell check

   To turn it on `:set spell`. To turn it off `:set nospell`

   Using Spellchecking:
   
   To move to a misspelled word, use `]s` (the next misspelled word) and `[s` (the previous misspelled word).
   
   Once the cursor is on the word, use z=, and Vim will suggest a list of alternatives that it thinks may be correct. If the list does not contain the word we are looking for, dismiss it with `Esc`
   
   What if Vim is wrong, and the word is correct? 
   zg - Add the current word to Vim's spell file. 
   zw - Remove the current word from Vim's spell file.
   zug - Revert zg or zw command for the current word.
   
   Usually, this is where the spell file will be :
   ~/.vim/spell/en.utf-8.add
   
   How to use it from insert modes?
   Ctrl x - Ctrl s
   Vim scans backward from the cursor position, stopping when it finds a mis-spelt word. It then builds a word list from suggested corrections and presents them in an autocomplete pop-up menu.
 
   ------------------------------------------

*** Non empty lines
   To do something only to non-empty lines, use `:g/./` before the command.
	:g/./ s/$/;/
	
	To do something only to the visually selected non-empty lines, use the same approach.

   ------------------------------------------


*** Marks
   https://vim.fandom.com/wiki/Using_marks

	| Command   | Description                                                   |
	|-----------+---------------------------------------------------------------|
	| ma        | set mark a at current cursor location                         |
	| 'a        | jump to line of mark a (first non-blank character in line)    |
	| `a        | jump to position (line and column) of mark a                  |
	| d'a       | delete from current line to line of mark a                    |
	| d`a       | delete from current cursor position to position of mark a     |
	| c'a       | change text from current line to line of mark a               |
	| y`a       | yank text to unnamed buffer from cursor to position of mark a |
	| :marks    | list all the current marks                                    |
	| :marks aB | list marks a, B                                               |
 
MARKS AND MOTIONS

| mc      | mark current position with mark c ∈[a..Z]    |
| `c `C   | go to mark c in current, C in any file       |
| `0..9   | go to last exit position                     |
| `` `"   | go to position before jump, at last edit     |
| `[ `]   | go to start, end of previously operated text |
| :marks↵ | print the active marks list                  |
| :jumps↵ | print the jump list                          |
| n^O     | go to nth older position in jump list        |
| n^I     | go to nth newer position in jump list        |

   ------------------------------------------
*** Visual Mode

| v V ^V   | start/stop highlighting characters, lines, block    |
| o        | exchange cursor position with start of highlighting |
| gv       | start highlighting on previous visual area          |
| aw as ap | select a word, a sentence, a paragraph              |
| ab aB    | select a block ( ), a block { }                     |

   ------------------------------------------

*** Registers and copy and paste
    
    COPY AND PASTE:
    How to copy a line in vim and paste it in a different program (a browser or word document or email):
    shift v (to select the line)
    (") quotation mark to select a register
    (+) we want to select the + register
    y - to yank
    
    Now, go to the other program and press Cntrol v to paste it.
    
    In the same way, if we want to copy something from a broser, copy it there and go to vim:
    " (to select a register) + (to select the + register) p (to paste it)
    
    When you copy something using the key 'y', go to a different location and delete a word in this location using the key 'd', and try to paste the text that was yanked before using either 'p' or 'P', the deleted word gets inserted instead of the word that was yanked earlier. This is very annoying. The reason for this is that when a word is deleted using the key 'd', it is also saved into the unnamed register, replacing the word that was originally yanked. When pasting text in the new location, paste it form the 0 (zero) register because, when a word is yanked, it is saved into the unnamed register and also the 0 register. But when a word is deleted using the key 'd', it is only put into the unnamed register but not into the 0 register. 
    Another way to paste the text without using registers at all is to visually select the text that you want to replace and use the key 'p' (to paste).
    
    ------------------------------------------
    Issue with copying/pasting to/from system clipboard?
    
    Be aware that copying/pasting from the system clipboard will not work if :echo has('clipboard') returns 0. 
    In this case, vim is not compiled with the +clipboard feature and you'll have to install a different version or recompile it. 
    Some linux distros supply a minimal vim installation by default, but generally if you install the vim-gtk or vim-gtk3 package you can get the extra features.
    
    ------------------------------------------
    "Hello" is in the "a" register
    "world" is in the "b" register
    
    How can I quickly type "Hello world"?
 
   ------------------------------------------

   | "x      | use register x for next delete, yank, put  |
   | :reg↵   | show the content of all registers          |
   | :reg x↵ | show the content of registers x            |
   | ym      | yank the text of movement command m        |
   | yy or Y | yank current line into register            |
   | p P     | put register after, before cursor position |
   | ]p [p   | like p, P with indent adjusted             |
   | gp gP   | like p, P leaving cursor after new text    |

   ------------------------------------------
   
UNDOING, REPEATING & REGISTERS

| u U      | undo last command, restore last changed line            |
| .  ^R    | repeat last changes, redo last undo                     |
| n.       | repeat last changes with count replaced by n            |
| qc qC    | record, append typed characters in register c           |
| q        | stop recording                                          |
| @c       | execute the content of register c                       |
| @@       | repeat previous @ command                               |
| :@c↵     | execute register c as an Ex command                     |
| :rg/p/c↵ | execute Ex command c on range r where pattern p matches |

   ------------------------------------------

Copying and Moving Text

| "{a-zA-Z0-9.%#:-"}         | Use register {a-zA-Z0-9.%#:-"} for next delete, yank or put (use uppercase character to append with delete and yank) ({.%#:} only work with put). |
| :reg[isters]               | Display the contents of all numbered and named registers.                                                                                         |
| :reg[isters] {arg}         | Display the contents of the numbered and named registers that are mentioned in {arg}.                                                             |
| :di[splay] [arg]           | Same as :registers.                                                                                                                               |
| ["x]y{motion}              | Yank {motion} text [into register x].                                                                                                             |
| ["x]yy                     | Yank [count] lines [into register x]                                                                                                              |
| ["x]Y                      | yank [count] lines [into register x] (synonym for yy).                                                                                            |
| {Visual}["x]y              | Yank the highlighted text [into register x] (for {Visual} see Selecting Text).                                                                    |
| {Visual}["x]Y              | Yank the highlighted lines [into register x]                                                                                                      |
| :[range]y[ank] [x]         | Yank [range] lines [into register x].                                                                                                             |
| :[range]y[ank] [x] {count} | Yank {count} lines, starting with last line number in [range] (default: current line), [into register x].                                         |
| ["x]p                      | Put the text [from register x] after the cursor [count] times.                                                                                    |
| ["x]P                      | Put the text [from register x] before the cursor [count] times.                                                                                   |
| ["x]gp                     | Just like "p", but leave the cursor just after the new text.                                                                                      |
| ["x]gP                     | Just like "P", but leave the cursor just after the new text.                                                                                      |
| :[line]pu[t] [x]           | Put the text [from register x] after [line] (default current line).                                                                               |
| :[line]pu[t]! [x]          | Put the text [from register x] before [line] (default current line).                                                                              |

   ------------------------------------------

*** Ex commands

   EX COMMANDS (↵)

| :e f            | edit file f, unless changes have been made     |
| :e!  f          | edit file f always (by default reload current) |
| :n :N           | edit next, previous file in list               |
| :rw             | write range r to current file                  |
| :rw f           | write range r to file f                        |
| :rw>>f          | append range r to file f                       |
| :q :q!          | quit and confirm, quit and discard changes     |
| :wq or :x or ZZ | write to current file and exit                 |
| :wn :wN         | write file and edit next, previous one         |
| <up> <down>     | recall commands starting with current          |
| :r f            | insert content of file f below cursor          |
| :r!  c          | insert output of command c below cursor        |
| :args           | display the argument list                      |
| :rco  a :rm  a  | copy, move range r below line a                |

   ------------------------------------------

SAVE ALL OPEN BUFFERS AT ONCE

Vim can open multiple files, each in its own buffer. Here is how to save all changes and continue working, or save all changes and exit Vim. It is also possible to quit all (discard changes).
| :wa  | write all changed files (save all changes), and keep working |
| :xa  | exit all (save all changes and close Vim)                    |
| :wqa | same as :xa                                                  |
| :qa  | quit all (close Vim, but not if there are unsaved changes)   |
| :qa! | quit all (close Vim without saving—discard any changes)      |

The :wa and :xa commands only write a file when its buffer has been changed. By contrast, the :w command always writes the current buffer to its file (use :update to save the current buffer only if it has been changed).

Warning: If you enter :qa!, Vim will discard all changes without asking "are you sure?". 

   ------------------------------------------

EX RANGES

| , ;     | separates two lines numbers, set to first line |
| n       | an absolute line number n                      |
| .   $   | the current line, the last line in file        |
| % *     | entire file, visual area                       |
| 't      | position of mark t                             |
| /p/ ?p? | the next, previous line where p matches        |
| +n -n   | +n, -n to the preceding line number            |
    
   ------------------------------------------

*** Word and text manipulation
      
     https://vim.fandom.com/wiki/Search_and_replace#substitute_last_search

**** WORD MANIPULATION:
     
     Quickly change word or line : To quickly change a word you can use cw,caw (change a word) or ciw (change in word). Use c$ or just C to quickly change from the cursor to the end of a line, cc to change an entire line, or cis (change in sentense) for a sentence
     
     | ea                               | To append something to a word (at the end of the word)     |
     | dw (vw to select in visual mode) | To delete a word along with the whitespace after the word  |
     | de (ve to select in visual mode) | To delete a word but not the the whitespace after the word |
     
**** TEXT SELECTION :
     
     If you want to do the same thing to a collection of lines, like cut, copy, sort, or format, you first need to select the text. Get out of insert mode, hit one of the options below, and then move up or down a few lines. You should see the selected text highlighted.
     
     | V      | selects entire lines  |
     | v      | selects range of text |
     | ctrl-v | selects columns       |
     | gv     | reselect block        |
     
     After selecting the text, try d to cut/delete, or y to copy, or :s/match/replace/, or :center, or !sort, or...
     Move to cursor where you would like to paste.
     Press P to paste before the cursor, or p to paste after.
     
**** SEARCH AND REPLACE :
     
     How do I convert all occurrences of ABC to XYZ in a file using the vi/vim editor?
    #+BEGIN_EXAMPLE
     :1,$s/ABC/XYZ/g   and then press [Enter].
    #+END_EXAMPLE
     This vi command replaces every occurrence of ABC with XYZ on every line, and even when there are multiple occurrences on a line.
     Note that in this example, the "g" character at the end of the command means "global".
     If you don't use this "g" the tab character will only be replaced the first time it is seen on a line, but if you add the "g" at the end of the command every tab character in each line will be replaced.
     
     -------------------------------------------------------------

     How to select a word within Vim and replace it with something else?
     
     (a quick search on the internet shows many ways to do this. but here is a simple way to do it)
     
     `:%s//bar/g`
         Replace each match of the last search pattern with 'bar'. 
         For example, you might first place the cursor on the word foo then press * to search for that word. 
         The above substitute would then change all words exactly matching 'foo' to 'bar'.
         
     Refer to [this page](https://vim.fandom.com/wiki/Search_and_replace#substitute_last_search) for more examples

     -------------------------------------------------------------
    #+BEGIN_EXAMPLE
     / : Search
     */# : Search forward/back for word under cursor
    #+END_EXAMPLE
     
     | :%s/search for this/replace with this/  | search whole file and replace                  |
     | :%s/search for this/replace with this/c | confirm each replace                           |
     | 1,$s/\t/    /g                          | To convert each tab in the file to four spaces |
     | :%s/\t/    /g                           | How to replace all tabs with spaces            |
     
     General tips for searching : 
     
     | /pattern        | search forward for pattern    |
     | ?pattern        | search backward               |
     | n               | repeat forward search         |
     | N               | repeat backward               |
     | :set ignorecase | case insensitive              |
     | :set smartcase  | use case if any caps used     |
     | :set incsearch  | show match as search proceeds |
     | :set hlsearch   | search highlighting           |
     
     More cool searching tricks:
     | *              | search for word currently under cursor               |
     | g*             | search for partial word under cursor (repeat with n) |
     | ctrl-o, ctrl-i | go through jump locations                            |
     | [I             | show lines with matching word under cursor           |
     
     -----------------------------------------------------------

     | :g/<pattern>/j                                                                                     | To join lines within a pattern                                                                                                                                                                                                        |
     | :g/.*(underscore)(underscore)text.*/j                                                              | To join the subsequent line with a line containing a certain text                                                                                                                                                                     |
     | :%s/{\(underscore)s.*(underscore)(underscore)text/{(underscore)(underscore)text/g                                                                         | Join two lines with a pattern ending on one line and a pattern beginning on the subsequent line. This looks for lines ending with "{" and a next line starting with the text (a wildcard) "(underscore)(underscore)text" and joins them into a single line. |
     | :%s/' ,/',\r/g                                                                                     | Replace each "' }," in the current file by a new line                                                                                                                                                                                 |
     | :{\(underscore)$\(underscore)s*(underscore)(underscore)prefix                                      | This searches for lines ending with `{` and a subsequent line starting with `(underscore)(underscore)prefix`.                                                                                                                         |
     | :',\(underscore)$\(underscore)s*(underscore)(underscore)text                                       | This searches for lines ending with `',` and a subsequent line starting with `(underscore)(underscore)text`.                                                                                                                          |
     | :%s/',\(underscore)$\(underscore)s*(underscore)(underscore)text/',(underscore)(underscore)text/g   | This searches for lines ending with `',` and a subsequent line starting with `(underscore)(underscore)text` and joins the two lines together.                                                                                         |
     | :%s/{\(underscore)$\(underscore)s*(underscore)(underscore)prefix/{(underscore)(underscore)prefix\g | This searches for lines ending with `{` and a subsequent line starting with `(underscore)(underscore)prefix` and joins the two lines together.                                                                                        |
     | :g/.*(underscore)(underscore)prefix.*(underscore)(underscore)text.* },\(underscore)$/normal! @a    | Record a macro in register a and play it on a pattern match.                                                                                                                                                                          |
     | :g/pattern to match/ s/text to search/text to replace/gc                                           | How to mix global command and replace command? Using the above command or variants of it, we can search for patterns in the entire file and do replace operations on those specific lines.                                            |
     
     -------------------------------------------------------------

**** COUNTING WORDS OR PATTERNS
     
     * Count the number of occurrences of a word or pattern in the current file : 
     
       #+BEGIN_EXAMPLE
            (first use * on the word)
        
            after that, use the following command to get a count : %s///gn
       #+END_EXAMPLE
     
         We are actually calling the :substitute command, but the n flag suppresses the usual behaviour.
         Instead of replacing each match witht the target, it simply counts the number of matches and then echoes the result below the command line.
         Do not omit any of the forward slashes.
         g stands for global (in the curent file).
     
     * Find all occurrences of a word in the current file and populate the quickfix list window
     
       #+BEGIN_EXAMPLE
            :vim /pattern/ % | cw
       #+END_EXAMPLE
     
     ------------------------------------------------
     
    #+BEGIN_EXAMPLE
    ~ & -
    #+END_EXAMPLE
    Repeat last substitution on current line
     
     ------------------------------------------------
     
     Insert mode tips :
     
    #+BEGIN_EXAMPLE
     gi - (incredibly handy) - goes to Insert mode where you left it last time
    #+END_EXAMPLE
     e.g. scenario: edit something, exit Insert, go look at something else, then gi back to restart editing
     
    #+BEGIN_EXAMPLE
     CTRL-T and CTRL-D (tab and de-tab)
    #+END_EXAMPLE
     inserts or deletes one shiftwidth of indent at the start of the line

   ------------------------------------------

*** Working with multiple files

    https://vim.fandom.com/wiki/Quick_tips_for_using_tab_pages
    https://vim.fandom.com/wiki/Using_tab_pages
    http://vimdoc.sourceforge.net/htmldoc/tabpage.html
    
**** Buffers

    How to view all open buffers?
    :buffers
    
    This will show a numbered list with all open buffers. To go to a specific buffer (file), do `:b5` (to go to the buffer with the number 5)
    Tip: the numbers on buffers do not change during a session.

    -------------------------------------------------------------------------------------

    Get the name of the current file 

    When working in a file/buffer, how to paste the name of the file/buffer in it?
    "%p
    This is because, the name of the file is available in the register "%".
    
    
    Register % contains the name of the current file, and register # contains the name of the alternate file. These registers allow the name of the current or alternate files to be displayed or inserted. The name, or full path, or directory containing the file can be used.

    For example, in directory /abc the command vim def/my.txt would edit file /abc/def/my.txt. The following commands could be entered to display the information shown.
    
    | :echo @%                | def/my.txt      | directory/name of file (relative to the current working directory of /abc)                                                               |
    | :echo expand('%:t')     | my.txt          | name of file ('tail')                                                                                                                    |
    | :echo expand('%:p')     | /abc/def/my.txt | full path                                                                                                                                |
    | :echo expand('%:p:h')   | /abc/def        | directory containing file ('head')                                                                                                       |
    | :echo expand('%:p:h:t') | def             | First get the full path with :p (/abc/def/my.txt), then get the head of that with :h (/abc/def), then get the tail of that with :t (def) |
    | :echo expand('%:r')     | def/my          | name of file less one extension ('root')                                                                                                 |
    | :echo expand('%:e')     | txt             | name of file's extension ('extension')                                                                                                   |
    
    The following commands insert lines consisting of the full path of the current and alternate files into the buffer:

    :put =expand('%:p')
    :put =expand('#:p')

    -------------------------------------------------------------------------------------

    (This is the general method to update multiple java files at once)
    
    Option 1 (Do not use this):
    
    If you want to open all files matching the pattern in subfolders - :args **/*.java
    
    To replace four white spaces in java files with a tab use this - :bufdo exexute "%s/    /(press tab)/g" | update
    
    #+BEGIN_EXAMPLE
    1. :bufdo execute "%s/(press tab){/{/g" | update
    1. :bufdo execute "global/^{/normal -gJ" | update
    1. :bufdo execute "%s/){/) {/g" | update
    #+END_EXAMPLE

    Option 2:
    Use Rg and cfdo as explained in the fzf document.
    
    -------------------------------------------------------------------------------------

**** Tabs

   CREATING AND CLOSING TABS
   
    | :tabnew      | To open a new tab with an empty buffer           |
    | :tabe <file> | to edit file in a new tab                        |
    | :tabc        | to close a tab and all the buffers in it         |

    #+BEGIN_EXAMPLE
        :tabs		List the tab pages and the windows they contain.
        		Shows a ">" for the current window.
        		Shows a "+" for modified buffers.
        		For example:
        			Tab page 1 ~
        			  + tabpage.txt ~
        			    ex_docmd.c ~
        			Tab page 2 ~
        			>   main.c ~
    #+END_EXAMPLE
    
    This will show a numbered list with all open tabs. To go to a specific tab, do `:5gt` (to go to the tab with the number 5)

    | :tabs        | List the tab pages and the windows they contain.    |
    | g<Tab>       | Go to the last accessed tab page.                   |
    | :gt          | Go to the next tab                                  |
    | : gT         | Go to the previous tab                              |
    | : nnn gt     | Go to a numbered tab. For example, 3gt goes to tab 3 |
    | :tabn, :tabp | (or gt, gT to switch)                               |

    REORDERING TAB PAGES:
    
    | :tabm2          | moves the current tab to appear after tab 2. To move this tab to the first position, use :tabm0. To move this tab to the last position, just use :tabm |
    | :tabm[ove] +[N] | Move the current tab page N places to the right (with +) or to the left (with -).                                                                    |
    | :tabm[ove] -[N] | Move the current tab page N places to the right (with +) or to the left (with -).                                                                    |
    | :tabmove -      | move the tab page to the left                                                                                                                        |
    | :tabmove -1     | as above                                                                                                                                             |
    | :tabmove +      | move the tab page to the right                                                                                                                       |
    | :tabmove +1     | as above                                                                                                                                             |
 
    -------------------------------------------------------------------------------------
    
     Open question - how to move buffers from one tab to another or into split windows when wanted?
     It may not be such a great idea to work on multiple windows in a given tab, unless there is a need for it.
     Always prefer to work only on one buffer in a tab because that will give maximum visibility into the open buffer.
     If there is a need to work on another file/buffer at the same time, put it in a separate tab.
     For now, just go to the tab that you want to open split windows in and use :vsp to split it and open the file that you want to view as a split window.
    
    -------------------------------------------------------------------------------------
    
    How to open buffers in tabs from netrw: One way is to change netrw settings using vimrc. The other way is, open it in a window and move it into a tab using Cntrl W T
    
    How to move an existing window (split) and put it in a new tab?  Ctrl W followed by T
    
    -------------------------------------------------------------------------------------  
    
**** Splits and Multiple windows

    How do I change the current split's width and height?
    
    | Ctrl+W +/-       | increase/decrease height (ex. 20<C-w>+)                                             |
    | Ctrl+W >/<       | increase/decrease width (ex. 30<C-w><)                                              |
    | Ctrl+W _         | set height (ex. 50<C-w>_)                                                           |
    | Ctrl+W    (pipe) | set width (ex. 50<C-w>)                                                             |
    | Ctrl+W =         | equalize width and height of all windows                                            |
    | ^Ws or :split↵   | split window in two                                                                 |
    | ^Wn or :new↵     | create new empty window                                                             |
    | ^Wo or :on↵      | make current window one on screen                                                   |
    | ^Wj ^Wk          | move to window below, above                                                         |
    | ^Ww ^W^W         | move to window below, above (wrap)                                                  |
    | :e filename      | Edit another file                                                                   |
    | :split filename  | Split window and load another file                                                  |
    | CTRL-W v         | Vertical split current window                                                       |
    | CTRL-W s         | Horizontal split current window                                                     |
    | CTRL-W Arrow Up  | Move cursor up a window                                                             |
    | CTRL-W CTRL-W    | Move cursor to another window (cycle)                                               |
    | CTRL-W_          | Maximize current window                                                             |
    | CTRL-W=          | Make all equal size                                                                 |
    | 10 CTRL-W+       | Increase window size by 10 lines                                                    |
    | :vsplit file     | Vertical split                                                                      |
    | :sview file      | Same as split, but readonly                                                         |
    | :hide            | Close current window                                                                |
    | :only            | Keep only this window open                                                          |
    | :ls              | Show current buffers                                                                |
    | :b 2             | Open buffer #2 in this window                                                       |
    | :bd[n]           | Close current buffer. If [n] is given close buffer #n. #n can be gathered with :ls. |

    See also: :help CTRL-W

    These mappings will help it a little easier.
    (pressing + is too difficult. = is + without having to press shift.)
    (pressing - is easy enough.)
    nnoremap <Leader>= :vertical resize +5<CR>
    nnoremap <Leader>- :vertical resize -5<CR>

   ------------------------------------------
    
*** Vim help
   Opening Vim help in a vertical split window

    #+BEGIN_EXAMPLE
   :vertical (vert)

   :vert help
    #+END_EXAMPLE

   You can also control whether the window splits on the left/top or the right/bottom with topleft (to) and botright (bo). For example, to open help in the right window of a vertical split:

    #+BEGIN_EXAMPLE
   :vert bo help
    #+END_EXAMPLE
 
   ------------------------------------------

*** Key mappings and abbreviations

| :map c e↵              | map c ↦ e in normal & visual mode             |
| :map!  c e↵            | map c ↦ e in insert & cmd-line mode           |
| :unmap c↵  :unmap!  c↵ | remove mapping c                              |
| :mk f↵                 | write current mappings, settings... to file f |
| :ab c e↵               | add abbreviation for c ↦ e                    |
| :ab c↵                 | show abbreviations starting with c            |
| :una c↵                | remove abbreviation c                         |
   
   ------------------------------------------

*** Tags in Vim

    cTags in Vim

   https://andrew.stwrt.ca/posts/vim-ctags/

   You would have to install cTags separately. It does not come with Vim.
  
   How to generate tags and use them for navigation in a big java project?
   Go to the root folder of the project and execute this command : ctags -R
   
   The next step is to get the full path of this tags file - in Linux, use the readlink utility to get the full path.
   [n0281526@VDDP14P-4UCXMSH renters-api-sb2]$ readlink -f tags
   /home/n0281526/Downloads/GitRepositories/renters-api-sb2/tags
   
   open a file in the root folder of the project and run this command from within vim (use semi-colon and then type it)
   set tags=./tags;/
   (It starts with a tags file in the current directory and goes up to the root directory.)
   
   ---------------------------------------------------------------------------------------------------

   One line that always goes in my .vimrc:
   set tags=./tags;/
   This will look in the current directory for "tags", and work up the tree towards root until one is found. In other words, you can be anywhere in your source tree instead of just the root of it.
   
   ---------------------------------------------------------------------------------------------------
   Ctrl+] - go to definition
   Ctrl+T - Jump back from the definition.
   Ctrl+W Ctrl+] - Open the definition in a horizontal split
   
   Add these lines in vimrc
   map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
   map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
   
   Ctrl+\ - Open the definition in a new tab
   Alt+] - Open the definition in a vertical split
   
   After the tags are generated. You can use the following keys to tag into and tag out of functions:
   
   Ctrl+Left MouseClick - Go to definition
   Ctrl+Right MouseClick - Jump back from definition
   
   | :ta t↵       | jump to tag t                                 |
   | :nta↵        | jump to nth newer tag in list                 |
   | ^] ^T        | jump to the tag under cursor, return from tag |
   | :ts t↵       | list matching tags and select one for jump    |
   | :tj t↵       | jump to tag or select one if multiple matches |
   | :tags↵       | print tag list                                |
   | :npo↵  :n^T↵ | jump back from, to nth older tag              |
   | :tl↵         | jump to last matching tag                     |
   | ^W}  :pt t↵  | preview tag under cursor, tag t               |
   | ^W]          | split window and show tag under cursor        |
   | ^Wz or :pc↵  | close tag preview window                      |

   ---------------------------------------------------------------------------------------------------
 
*** Deleting

   | x X   | delete character under, before cursor      |
   | dm    | delete text of movement command m          |
   | dd D  | delete current line, to the end of line    |
   | J gJ  | join current line with next, without space |
   | :rd↵  | delete range r lines                       |
   | :rdx↵ | delete range r lines into register x       |

***** Delete up until a word

    #+BEGIN_EXAMPLE
   Put your cursor at the point you want to start at.
   Make sure you're in command mode.
   hit v to start a visual selection
   then hit / and type the word you're looking for to select up to it, then press enter to make the selection
   then hit d to delete the text 
    #+END_EXAMPLE
   
***** Delete a word along with the whitespace after the word 

     dw (vw to select in visual mode)
   
***** Delete a word but not the the whitespace after the word 
   
     de (ve to select in visual mode)
   
***** Delete unnecessary spaces and tabs in empty lines in Vim-:
   
   * (these don't seem to work with eclipse vim plugin and emacs vi mode)
   
       In a search, \s finds whitespace (a space or a tab), and \+ finds one or more occurrences.
   
       The following command deletes any trailing whitespace at the end of each line. If no trailing whitespace is found no change occurs, and the e flag means no error is displayed.
   
       :%s/\s\+$//e
   
***** Delete whitespace in blank lines

       :%s/^\s\+$//

       % — execute for all lines
       s/^\s\+$// — search and replace command:
             search lines that only have whitespaces
             and replace with an empty string.
   
***** Delete all text before search pattern

   If you have a file that looks like below
   1: #sometext
   2: #sometext
   3: #sometext

   If you want to delete the text before the pattern ":" (colon). I have used the following command to replace every :%s/^.*/\://
   If want to delete the texts after the pattern ":" (colon). I have used the following command to replace every :%s/\:.*$//
   I would like to learn other ways to do.
   
   Another answer : 
   Do you want to not include the colon?
   If so, then for deleting everything before (but not including) the colon :%s/.*\ze://
   And for everything after :%s/:\zs.*//
   See :help \zs and :help \ze for more info.
   
   These atoms are amazing! After I discovered them, I started using them all the time. I remember them as z == zero-width (since they don't match anything).
   
   If you want to delete all characters before "Hello", you can do
   :%s/.*Hello/Hello/
   Note that .* is greedy, i.e. it will eat all occurrences of "Hello" till it finds the last one. If you have a line:
   abcHellodefHelloghi - it will become - Helloghi
   If you want a non-greedy solution, try - :%s/.\{-}Hello/Hello
   

***** Delete duplicate rows in vi 
      
      :sort u
   
***** Delete all blank(empty) lines

   To delete blank lines in vim (empty lines), use this command - :g/^$/d
   
   The g character says, “perform the following operation globally in this file.” (Operate on all lines in this file.)
   The forward slash characters enclose the pattern I’m trying to match. In this case I want to match blank lines, so I use the regular expression ^$. Here the ^ means “beginning of line,” and $ means “end of line,” so with no characters in between them, this vim regex means “blank line.” (If I had typed ^abc$, that would mean, “find a line with only the sequence of characters ‘abc’”.)
   The d at the end of the command says, “When you find this pattern, delete the line.”
   
***** Delete Lines Beginning With A certain text In Vim 

   :g/^(enter text here)/d
   
***** Delete line containing certain text in vim with prompt 

   :%s/.*text.*\n//gc

   The substitute command works by 
   1. adding a wildcard
   2. and adding an end-of-line.
   
***** Delete all lines that do NOT contain a certain word in Vim
   
   :%g!/price/d  - this deletes every line that doesn't contain the word "price"
   
***** Delete trailing whitespaces at the end of each line
   
   The following command deletes any trailing whitespace at the end of each line. If no trailing whitespace is found no change occurs, and the e flag means no error is displayed.
   
   :%s/\s\+$//e
   
***** Delete text between all braces {} in vim

   You can do this with the global command. 
   :g/{/normal f{da{

   What is this doing:
   For all lines containing a {, move to the first { on that line and delete everything from there up to and including a matching }.

   If you want to add a ; at the end - which I suspect would be the next thing you'd want - you can add a A; at the end of that command.

   Note: This might break if you have comments or strings containing {}s in your file.

*** File comparison with Vim

   Comparing two files in Vim
   
***** Option 1:

   Open the side by side view:
   Ctrl+w v
   
   Change between them:
   Ctrl+w h or l
   
   Checkout the vimdiff command, part of the vim package, if you want a diff-like view:
   (from terminal)
   vimdiff file1.txt file2.txt
   
***** Option 2:
   
   Or just open the first file in VIM, then 
   :vert diffsplit ./file2 (if file2 is in the same folder as file1)
   (or)
   :vert diffsplit file2
   
   :vert makes it split the screen vertically.
   diffsplit does a diff, and splits the files and scrolls locks them.

*** Grep

    Sometimes, it is best not to run grep within Vim and to run it standalone in terminal :

    In terminal, navigate to the project folder and use this : grep -r -n -l i text_to_search *
    
    -r recursive - search in current and sub directories
    -n show line numbers in the results
    -l only list the names of the files
    i case insensitive search. grep is case sensitive by default
    * search in files of all types
    
    How to exclude one specific folder or a list of folders from the search results? e.g. 'node_modules' in a javascript project?
    
*** Installation

    In Redhat Linux, gVim can be installed using this : sudo yum install vim-X11
    
*** Indentation

   #+BEGIN_EXAMPLE
       Example line
           This is part of the parsed line
           Thats goes one
       End of line
   #+END_EXAMPLE

   How to remove all spaces in front of these lines? The final text should be:
   Example line
   This is part of the parsed line
   Thats goes one
   End of line
   
   Answer : To format a line to the left I use :left. Use this format an entire file :%le
   
   --------------------------------------------
   
   How to insert white spaces before a line?
   Here's one way to move selected text over a few spaces:
   
    - select a chunk of code using capital V and the arrow keys (or j, k)
    - type colon
    - then type s/^/   /
    - hit return
   
   What you've done is replace the beginning of each selected line (the ^ symbol means "the beginning of the line") with spaces. 
   
*** Line numbers

   To display line numbers :set number (To turn off the line number display :set nonumber)
   
   To enable line numbers on startup, simply add the following to your vimrc - set number
   
   Relative Line Numbers : To display line numbers relative to the line with the cursor, :set relativenumber or :set norelativenumber
   
*** Lower case Upper case

   How to change lower case letters words to upper case words? How to change upper case words to lower case words?
   
   You can change the case of text:
   #+BEGIN_EXAMPLE
       Toggle case "HellO" to "hELLo" with g~ then a movement (word or end of line). 
       Uppercase "HellO" to "HELLO" with gU then a movement (word or end of line). 
       Lowercase "HellO" to "hello" with gu then a movement (word or end of line). 
   #+END_EXAMPLE
   
       
   Alternatively(easier to remember), you can visually select text then press ~ to toggle case, or U to convert to uppercase, or u to convert to lowercase. 
   
*** Manual insertion of numbered lists

   How to insert numbered bullet list for a few lines in a file?
   
   It's not a macro solution, but at least it's easy:
   
   To add numbers to all lines - 
   
   	It's possible to use :%!nl -ba or :%!cat -n commands which will add line numbers to all the lines.
   
   On Windows, you've to have Cygwin/MSYS/SUA installed.
   
   Add numbers to selected lines - 
   
   	To add numbers only for selected lines, please select them in visual mode (v and cursors), then when finished - execute the command: :%!nl (ignore blank lines) or :%!cat -n (blank lines included).
   
   Formatting
   
   	To remove extra spaces, select them in visual block (Ctrl+v) and remove them (x).
   
   To add some characters (., :, )) after the numbers, select them in visual block (Ctrl+v), then append the character (A, type the character, then finish with Esc).
   
*** Macros

   Recording a macro is a great way to perform a one-time task, or to get things done quickly when you don't want to mess with Vim script or mappings, or if you do not yet know how to do it more elegantly. 

***** Recording a macro
   
   	Each register is identified by a letter a to z. To enter a macro, type: q<letter><commands>q
   	
   	To execute the macro <number> times (once by default), type: <number>@<letter>
   	
   	So, the complete process looks like:
   #+BEGIN_EXAMPLE
   	* qd 	start recording to register d
   	* ... 	your complex series of commands
   	* q 	stop recording
   	* @d 	execute your macro
   	* @@ 	execute your macro again 
   #+END_EXAMPLE
   
***** In Vim, how do we apply a macro to a set of lines?

   How to run a macro on the rest of the lines in the file without knowing the number of times it needs to be run?
   
   Use the normal command in Ex mode to execute the macro on multiple/all lines:
   
   Execute the macro stored in register a on lines 5 through 10.
   :5,10norm! @a
   
   Execute the macro stored in register a on lines 5 through the end of the file.
   :5,$norm! @a
   
   Execute the macro stored in register a on all lines.
   :%norm! @a
   
   Execute the macro store in register a on all lines matching pattern.
   Use global to run the macro 'a' on all lines that contain 'pattern'
   :g/pattern/norm! @a (:g/pattern/normal! @a)
   
   To execute the macro on visually selected lines, press V and the j or k until the desired region is selected. Then type :norm! @a and observe the that following input line is shown.
   :'<,'>norm! @a
   Enter :help normal in vim to read more.
   For help, check: :help global.
 
*** Netrw

   Vim documentation: http://vimdoc.sourceforge.net/htmldoc/pi_netrw.html#netrw

   Open question - netrw - always fix the width at 25%. Right now, it is at 25% on start-up but when a new buffer is opened, its size is changing.

   ------------------------------------------
   
   How to : always show line numbers in netrw:
   #+BEGIN_EXAMPLE
   		    " netrw_bufsettings - you can control netrw's buffer settings; change
   		    " these if you want to change line number displays, relative line number
   		    " displays and other settings in netrw menu.
   			let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'
   #+END_EXAMPLE
   
   The file explorer is just another Vim buffer, so you can navigate up and down with k and j keys, or jump to the bottom with G, etc. If it is a large file listing, you may be quicker finding your target by searching for it.
   
   There are a handful of useful commands for opening the file explorer - either in the current window or a split, focusing on the project root, or the directory of the most recent file edited. This table summarizes:

    |   lazy|	mnemonic |open file explorer|
    |   :e. |:edit . 	 |at current working directory|
    |   :sp.|	:split . |in split at current working directory|
    |   :vs.|	:vsplit .|in vertical split at current working directory|
    |   :E :|Explore 	 |at directory of current file|
    |   :Se |:Sexplore 	 |in split at directory of current file|
    |   :Vex|	:Vexplore|in vertical split at directory of current file|
   
   Manipulating the filesystem
   
   The file explorer includes commands for creating new files and directories, as well as renaming or deleting existing ones. This table summarizes these:
   | command | action                                     |
   | %       | create a new file                          |
   | d       | create a new directory                     |
   | R       | rename the file/directory under the cursor |
   | D       | Delete the file/directory under the cursor |

   
   Invoking netrw can be achieved in three ways
   | :Explore (:E)    | opens netrw in the current window                                            |
   | :Sexplore (:Sex) | opens netrw in a horizontal split                                            |
   | :Vexplore (:Vex) | opens netrw in a vertical split                                              |
   | :Texplore (:Tex) | opens netrw in a new tab (use Cntrl PgUp, Cntrl PgDn to switch between tabs) |
       
   --------------------------------------------
   
   NERDtree like setup
   If NERDtree is your thing, netrw can give you a similar experience with the following settings
   
   #+BEGIN_EXAMPLE
   let g:netrw_banner = 0 (To remove the directory banner)
   let g:netrw_liststyle = 3
   let g:netrw_browse_split = 4
   let g:netrw_altv = 1
   let g:netrw_winsize = 25
   augroup ProjectDrawer
     autocmd!
     autocmd VimEnter * :Vexplore
   augroup END
   #+END_EXAMPLE
   
   Vim also supports arbitrary commands to be run following !. For a quick directory listing the following works...  :! ls -lF
   For a more complex command other commands like ack, grep or find can be used.
   
   --------------------------------------------
   
   There are a number of ways to open files in vim and if that is what you use netrw for. 
   
   Using find within vim can open files and supports tab completion.
   :find path/to/file.txt
   
   To open a file in a vertical split use the following. This also supports tab completion.
   :vs path/to/file.txt
   
   To open a file in a horizontal split use the following. This also supports tab completion.
   :sp path/to/file.txt
   
   To open a file in a new tab use the following. This also supports tab completion.
   :tabnew path/to/file.txt
   
   --------------------------------------------
   
   How do I configure .vimrc so that line numbers display in netrw in Vim?
   
   I'm using netrw to read directory listings in Vim, and I would like to display line numbers in my netrw tabs (so I can use :24 to navigate through directory listings faster). I'm using "set number" in my vimrc to enable line numbers when editing files, but this does not display line numbers in netrw.
   
   When in netrw, if I type the command ":set number", the line numbers display, but as soon as I change directories the line numbers go away.
   
   Is there a configuration option I can put in .vimrc that will make line numbers show up in netrw windows?
   
   
   From autoload/netrw.vim in the runtime:
   
   call s:NetrwInit("g:netrw_bufsettings" , "noma nomod nonu nobl nowrap ro")
   
   s:NetrwInit overrides a variable only if it is not defined.
   
   Therefore put let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro' in your vimrc and it should work. 
   
   --------------------------------------------

   Further Reading
       :help netrw
       :help :edit
       :help :Explore
   --------------------------------------------
   
*** Packages and plugins

   Vim's official plugin install method:
   https://github.com/vim/vim/blob/03c3bd9fd094c1aede2e8fe3ad8fd25b9f033053/runtime/doc/repeat.txt#L515
   
   Manual installation of packages in Windows:
   Create the folder "\[your-name]\start" if it doesn't exist and clone the git repositories into it or manually copy the repositories into this folder.
   C:\Program Files\Vim\vim82\pack\[your-name]\start

   Protip: To learn more about any plugin, simply prepend "https://github.com/" to any plugin name. So if you see this line in a .vimrc file:

   #+BEGIN_EXAMPLE
      Plug 'pechorin/any-jump.vim'
   #+END_EXAMPLE

   change it to this to get the plugin's URL: 
   #+BEGIN_EXAMPLE
      https://github.com/pechorin/any-jump.vim
   #+END_EXAMPLE

*** git

**** gitignore 

    Vim creates temporary files throughout the project. One way to stop that is by using the following settings:   
   #+BEGIN_EXAMPLE
    set nobackup       "no backup files
    set nowritebackup  "only in case you don't want a backup file while editing
    set noswapfile     "no swap files
   #+END_EXAMPLE
    
    Instead of changing Vim settings, just add the following lines to the project's gitignore files
   #+BEGIN_EXAMPLE
    *~
    *.swp
    *.swo
   #+END_EXAMPLE

**** If Vim does not recognize Git

     Symptom : If there is an error when Vim is starting up due to the call plug#begin(), it indicates that Vim may not be recognizing Git appropriately. This might show up when using PlugInstall command or any other plugin manager.

     Do you have git installed on your system? What does :echo executable('git') say?

     If it says 0, then add these to the vimrc file:
     
     (for 32 bit machines)
     
#+BEGIN_EXAMPLE
     if has('win32')
     
         let $PATH .= ';' . 'C:/Program Files (x86)/Git/bin'
     
     endif
#+END_EXAMPLE
     
     (for 64 bit machines)
     
#+BEGIN_EXAMPLE
     if has('win64')
     
         let $PATH .= ';' . 'C:/Program Files/Git/bin/'
     
     endif
#+END_EXAMPLE

**** If the plugin managing tools have trouble connecting to git when working in a corporate environment:

    Unable to resolve “unable to get local issuer certificate” using git on Windows with self-signed certificate

    Open Git Bash and run the command if you want to completely disable SSL verification.
    
   #+BEGIN_EXAMPLE
    git config --global http.sslVerify false
   #+END_EXAMPLE
    
    Note: This solution may open you to attacks like man-in-the-middle attacks. Therefore turn on verification again as soon as possible:
    
   #+BEGIN_EXAMPLE
    git config --global http.sslVerify true 
   #+END_EXAMPLE

*** Helpful links

| https://vim.fandom.com/wiki/Search_across_multiple_lines |
| https://vimhelp.org/                                     |
| https://sanctum.geek.nz/arabesque/advanced-vim-macros/   |
| https://vim.fandom.com/wiki/Copy,_cut_and_paste          |
| https://vim.fandom.com/wiki/Power_of_g                   |

*** Open questions
    
    1. Open question - how to move an entire paragraph (or block of code) up? (like alt up arrow  or down arrow in visual studio code)
    1. Open question - how to move an entire line up? (like alt up arrow  or down arrow in visual studio code)
    1. Put the cursor on the first line (the line that needs to be moved to the next line) and do "ddpP" (deleting it from its current position and pasting if after the subsequent line). This will work with single lines. This will not work with paragraphs.
    1. Open question - how to do file comparison using Vim?
    1. What is Vim maillist archives? Bram Moolenar talks about it in the talk "7 tips for highly effective text editiong"
    1. How to use folding in Vim? 
    1. To minimise the method/function implementation. (-) - minus? need a working example.
    1. color schemes in Vim
    1. vimrc shortcut for finding and displaying all the occurences of a word

*** Research

   Interesting comments about Vim :

   It's simply a piece of software that integrates several tools needed for Development in a single instance.
   Vim comes bare bone but plug ins can easily be installed using Plug ins Manager such as Vundle or Vim Plug.
   
   It can then provide for capabilities including but not limited to:
   
   - Version control within a few strokes such as GitGutter and Fugitive e.g. :Gstatus
   
   - Syntax checking using Syntastic
   
   - NERDTree to provide Tree like document view
   
   - Goyo providing Zen Mode
   
   - Plethora of themes and awesome power lines such as Airline
   
   - Spell checker that comes by default
   
   - EasyMotion for rapid motion throughout a document without the use of the mouse
   
   - Additional support for languages such as Markdown
   
   
*** Terminal

   Launch terminal from within Vim using `:term`
 
   How to switch between Vim and terminal when using Vim in a terminal (found this when looking for differences between Vim and GVim)
   
   With vim (not gVim) you can get benefit from ctrl-Z
   
   if you want to test your codes in shell/terminal, or execute some shell commands during your editing. 
   In vim you can just ctrl-z to back to terminal do what you want, and fg back to vim. 
   With Gvim, you cannot do that. 

*** Miscellaneous

| :sh↵  :!c↵          | start shell, execute command c in shell          |
| K                   | lookup keyword under cursor with man             |
| :make↵              | start make, read errors and jump to first        |
| :cn↵  :cp↵          | display the next, previous error                 |
| :cl↵  :cf↵          | list all errors, read errors from file           |
| ^L ^G               | redraw screen, show filename and position        |
| g^G                 | show cursor column, line, and character position |
| ga                  | show ASCII value of character under cursor       |
| gf                  | open file which filename is under cursor         |
| :redir>f↵           | redirect output to file f                        |
| :mkview [f]         | save view configuration [to file f]              |
| :loadview [f]       | load view configuration [from file f]            |
| ^@ ^K ^_  \  Fn ^Fn | unmapped keys                                    |

*** Plugins

Please see the individual pages for them.
